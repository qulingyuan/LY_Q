## 链表特点

元素存储不连续，靠指针确定下一个元素的位置。删除和插入元素的时间复杂度O(1)，无法随机访问，查找时间复杂度为 O(n)。

## 数组特点

元素连续存储，通过索引查找元素，可以随机访问，查找的时间复杂度为 O(1)。数组中间插入和删除元素的时间复杂度为 O(n)。

JS中的链表：使用Object来模拟链表

## 链表的常见操作/技巧

JavaScript 中单链表的定义：

```javascript
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}
```

### 虚拟头节点

也称 `dummy` 节点，主要是为了解决递归操作时头节点和尾节点的特殊性。在 `head` 节点前添加 `dummy` 节点，然后就可以把 `head` 节点当做普通节点处理。

```javascript
let dummy = new ListNode(-1);
dummy.next = head;
//最后返回：
return dummy.next;
```

### 双指针

[19. 删除链表的倒数第 N 个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```javascript
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode();
    dummy.next = head;
    let p1 = dummy;
    let p2 = dummy;
    while(n --){
        p1 = p1.next;
    }
    while(p1.next !== null){
        p1 = p1.next;
        p2 = p2.next;
    }
    p2.next = p2.next.next;
    return dummy.next;
};
```



### 快慢指针

适用于**判断链表是否闭环**等操作。



### 链表的基本操作

```javascript
const a = { val: "a" };
const b = { val: "b" };
const c = { val: "c" };
const d = { val: "d" };
//创建链表
a.next = b;
b.next = c;
c.next = d;

//遍历链表
let p = a;
while (p) {
  console.log(p.val);
  p = p.next;
}
//插入
const e = { val: "e" };
c.next = e;
e.next = d;
//删除
c.next = d;

//js中单链表的定义
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}
```



[LeetCode_237_删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

#### 解题思路

- 无法直接获取被删除节点的上个节点。
- 将被删除节点转移到下个节点。

#### 解题步骤

- 将被删节点的值改为下个节点的值。
- 删除下个节点。

#### 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    node.val = node.next.val;
    node.next = node.next.next;
};
```



[LeetCode_206_反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

#### 解题思路

- 反转两个节点：将 n+1 的 next 指向 n。
- 反转多个节点：双指针遍历链表，重复上述操作。

#### 解题步骤

- 双指针一前一后遍历链表
- 反转双指针

#### 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let curr = head;
    let prev = null;
    while(curr!==null){
        const tempNext = curr.next;
        curr.next = prev;
        prev = curr;
        curr = tempNext;
    }
    return prev;
};
```

[LeetCode_2_两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

#### 解题思路

- 小学数学题，模拟相加操作。
- 需要遍历链表。

#### 解题步骤

- 新建一个空链表
- 遍历被相加的两个链表，模拟相加操作，将个位数追加到新链表上，将十位数留到下一位去相加。

#### 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    const l3 = new ListNode(0);
    let p1 = l1;
    let p2 = l2;
    let p3 = l3;
    let carry = 0;
    while(p1 || p2){
        const v1 = p1 ? p1.val : 0;
        const v2 = p2 ? p2.val : 0;
        const val = v1 + v2 + carry;
        carry = Math.floor(val / 10);
        p3.next = new ListNode(val % 10);
        if(p1) p1 = p1.next;
        if(p2) p2 = p2.next;
        p3 = p3.next;
    }
    if(carry){
        p3.next = new ListNode(carry);
    }
    return l3.next;
};
```



[LeetCode_83_删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

#### 解题思路

- 因为链表是有序的，所以重复元素一定相邻。
- 遍历链表，如果发现当前元素和下个元素值相同，就删除下个元素值。

#### 解题步骤

- 遍历链表，如果发现当前元素和下个元素值相同，就删除下个元素值。
- 遍历结束后，返回原链表的头部。

#### 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    let p = head;
    while(p && p.next){
        if(p.val === p.next.val){
            p.next = p.next.next;
        }else{
            p = p.next;
        }
    }
    return head;
};
```

[LeetCode_141_环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

#### 解题思路

- 两个人在圆形操场上的起点同时起跑，速度快的人一定会超过速度慢的人一圈。
- 用一快一慢两个指针遍历链表，如果指针能够相逢，那么链表就有环。

#### 解题步骤

- 用一快一慢两个指针遍历链表，如果指针能够相逢，就返回 true。
- 遍历结束后，还没有相逢就返回 false。

#### 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    p1 = head;
    p2 = head;
    while(p1 && p2 && p2.next){
        p1 = p1.next;
        p2 = p2.next.next;
        if(p1 === p2){
            return true;
        }
    }
    return false;
};
```



#### 前端与链表

使用链表指针获取 JSON 的节点值。

```javascript
const json = {
  a: { b: { c: 1 } },
  d: { e: 2 },
};
const path = ["a", "b", "c"];
let p = json;
path.forEach((k) => {
  p = p[k];
});

```



### 技术总结

链表里的元素存储不是连续的，之间通过 next 连接。

JavaScript 中没有链表，但可以用 Object 模拟链表。

链表常用操作：修改 next、遍历链表。

JS 中的原型链也是一个链表。

使用链表指针可以获取 JSON 的某个节点值。