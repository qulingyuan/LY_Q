## 前言

在编程领域，垃圾回收表示清理不再需要的垃圾数据，释放内存空间。不同的语言有不同的回收方式，像 C 语言是需要程序员使用如`malloc()` 和 `free()` 等方法手动释放内存；而像 JavaScript 等语言则是通过垃圾回收器自动清理垃圾数据。

## 内存管理生命周期

js 内存生命周期一般可划分为三个阶段：

1. 分配内存：当创建变量或函数时，会为其分配内存空间。
2. 读写内存：使用上一步分配到的内存（读、写）。
3. 释放内存：当不再需要上面创建的变量时，释放内存空间。

栈内存与堆内存

js 数据类型基本可以分两大类：

基本类型：被放在栈内存中，特点是大小固定、体积较小、相对简单。包括 String、Number、Boolean、null、undefined、Symbol。

引用类型：被放在堆内存中，特点是大小不定、体积较大、比较复杂。包括 Object、Array、Function 等。

图示：

![栈堆内存](https://gitee.com/qulingyuan/ly_picture/raw/master/img/2022/01/%E6%A0%88%E5%A0%86%E5%86%85%E5%AD%98.png)

垃圾回收机制

js 的垃圾回收机制有两种：

1. 引用计数法

引用计数法会统计每一块堆内存被引用的计数。当贝引用的计数为 0，就将会被回收。

目前该方法已被淘汰。

缺点：无法甄别循环引用，可能会导致内存泄漏。

2. 标记清除法









在使用之前就需要确认其变量数据类型的称为静态语言；在运行过程中需要检查数据类型的语言称为动态语言。

**支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言**





**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**

另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，**产生的垃圾数据是由垃圾回收器来释放的**，并不需要手动通过代码来释放。

栈中有一个**记录当前执行状态的指针（称为 ESP）**，表示当前正在执行 showName 函数。

当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

**代际假说**有以下两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- **副垃圾回收器，主要负责新生代的垃圾回收。**
- **主垃圾回收器，主要负责老生代的垃圾回收。**

**不论什么类型的垃圾回收器，它们都有一套共同的执行流程**。

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。
