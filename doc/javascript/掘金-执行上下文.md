# 前言

在讲解执行上下文之前，先来看一段代码：

```javascript
console.log(myname);
showMsg();
var myname = "page_not_found";
function showMsg() {
  console.log("function console");
}
```

稍有 js 基础的同学都知道，这段代码并不会报错，代码会输出如下结果：

![image-20220524211640508](https://cdn.jsdelivr.net/gh/qulingyuan/ly_picture@master/img/202205242116636.png)

这是因为**JavaScript 引擎会将函数和变量的声明提升到作用域的顶部，这个特性我们一般称作变量提升/声明提升**。所以上面代码相当于下面的代码：

```javascript
//变量和函数的声明被提升到了作用域顶部
var myname; // 已声明未初始化的变量值为undefined
function showMsg() {
  console.log("function console");
}
//赋值&执行代码
console.log(myname);
showMsg();
myname = "page_not_found";
```

对于 `let`或`const` 声明的变量：

```javascript
console.log(myname);
let myname = "page_not_found";
```

执行结果：

![image-20220527101518963](https://cdn.jsdelivr.net/gh/qulingyuan/ly_picture@master/img/202205271015062.png)

 `let` 声明之前的执行瞬间被称为**暂时性死区**，在此阶段的变量引用均会输出 `ReferenceError`。

到这里，我们不得不发出疑问，为什么`var`声明的变量和函数的声明可以被提升？为什么 `let` 和 `const` 声明的变量在声明前不可用？要回答这个问题，我们必须要搞清楚 js 引擎是如何执行 js 代码的。

# js 执行流程

js 代码的执行分为两个阶段，分别为**编译阶段**和**执行阶段。** js 代码在执行前都会被编译。

因此，变量提升以及暂时性死区形成的实际原因是：在编译阶段，js 对代码的声明做了特别的处理，如果是 var 声明的就提升，如果是 `let` 声明的就标记为`ReferenceError`。

当然，这只是一个笼统的解释，想要了解内部的细节，我们必须要去了解执行上下文。

# 执行上下文

## 概念

当 js 代码被执行时，会创建执行上下文。执行上下文是 JavaScript 执行一段代码时的运行环境，包括了代码执行的所有信息。

## 种类

执行上下文有三种：

- 全局执行上下文：当 JavaScript 执行全局代码的时候，会创建全局执行上下文。它会做两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 `this` 的值等于这个全局对象。全局上下文只有一个。
- 函数执行上下文：函数被调用时才被创建，每次调用函数都会创建一个新的函数执行上下文。函数执行结束后，其上下文会被销毁。
- Eval 执行上下文：运行在 `eval` 函数中的代码，不建议使用。

## 执行上下文的属性

执行上下文主要包含三个属性：词法环境，变量环境以及 this 值。

### [词法环境](https://262.ecma-international.org/11.0/#sec-lexical-environments)(lexical environment)

词法环境由**环境记录**和**对外部环境的引用**两部分组成。

环境记录：存储变量和函数声明的实际位置

对外部环境的引用：表示其可以访问的外部词法环境

词法环境有两种类型：

1. 全局词法环境：全局词法环境没有外部环境，故其对外部环境的引用为 `null`。包含被定义的全局变量以及全局对象(浏览器中为window)，`this` 指向该全局对象。
2. 函数词法环境：对外部环境的引用可以是全局词法环境，也可以是包裹该函数的外部函数的函数词法环境。函数词法环境包含 arguments 对象以及函数中被定义的变量。

### 变量环境(variable environment)

变量环境也是一个词法环境，故其具有词法环境的所有属性。

## 执行上下文栈

用来存放执行上下文的栈结构，也称**调用栈**。

## 属性



## 执行阶段

每个执行上下文都有会经历两个阶段：

1. ### 创建阶段：
   会做代码执行前的准备工作，如声明提升等都是在此阶段做的。此时还没有执行代码。

   1. `lexical environment`(词法环境)组件被创建。
   2. `variable environment`(变量环境)组件被创建。

2. ### 执行阶段：
    逐行执行代码，完成所有变量的分配。

了解了执行上下文的两个阶段，再来具体看一下词法环境和变量环境在创建时都做了什么：

- #### `lexical environment`(词法环境)：

   词法环境有两个部分组成：

   1. **环境记录(EnvironmentRecord)**：存储变量和函数声明的实际位置（包括 `this` 绑定）。
   2. **对外部环境的引用**：可以访问其外部词法环境。

   词法环境有两种类型：

   1. **全局环境**：外部环境的引用为 `null`，拥有一个全局对象（`window` 对象），`this` 值指向这个全局对象。
   1. **函数环境**：在函数中定义的变量被存储在环境记录中，除此之外，环境记录中还包含了 `arguments` 对象，对外部环境的引用可能是全局环境，也可能是外部函数环境。

- #### `variable environment`(变量环境)：

   变量环境也是一个词法环境，故其具有词法环境的所有属性。
   

区别在于词法环境用于存储**函数声明和let、const声明的变量(标记为`uninitialized`)**绑定，而且函数声明在变量声明之前，且如果变量名称和函数名称相同，变量名称不会干扰函数名称；变量环境仅用于存储**var声明的变量(标记为 `undefined`)**绑定。

```javascript
let a = 20;  
const b = 30;  
var c;

function multiply(e, f) {  
 var g = 20;  
 return e * f * g;  
}

c = multiply(20, 30);
```

执行上下文如下所示：

```javascript
GlobalExectionContext = {

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      a: < uninitialized >,  
      b: < uninitialized >,  
      multiply: < func >,
      ThisBinding: <Global Object>,
    }  
    outer: <null>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      c: undefined,  
    }  
    outer: <null>  
  }  
}

FunctionExectionContext = {  

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      Arguments: {0: 20, 1: 30, length: 2},
      ThisBinding: <Global Object>,
    },  
    outer: <GlobalLexicalEnvironment>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      g: undefined  
    },  
    outer: <GlobalLexicalEnvironment>  
  }  
}
```

由上可知，`var` 的**变量提升**以及 `let`、`const` 的**暂时性死区**其实就是由于变量的创建和赋值在执行上下文的不同阶段导致的。在执行上下文创建阶段，`var` 声明的变量会被标记为 `undefined`，而 `let`、`const` 声明的变量会被标记为 `uninitialized`。函数的声明提升在变量的声明提升之前也是由于词法环境先于变量环境的创建导致的。

```javascript
console.log(foo);//打印函数

var foo = 1;

function foo(){
    console.log("foo");
}

console.log(foo);//输出 1
```

上面例子证明了函数声明在变量声明之前处理，且如果变量名称和函数名称相同，变量名称不会干扰函数名称。

## 概念

执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。

变量和函数的上下文决定了他们可以访问哪些数据，以及它们的行为。

JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为“执行上下文”。

执行栈（调用栈）用于存储在代码执行期间的所有执行上下文。

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```



```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```



```
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```



```
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```



```
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
```

会打印函数，而不是 undefined 。

这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

对于重复声明的函数，最后的函数声明会覆盖前面的函数声明。

```javascript

function showName() {
    console.log('极客邦');
}
showName();
function showName() {
    console.log('极客时间');
}
showName(); 
```



```javascript

showName()
var showName = function() {
    console.log(2)
}
function showName() {
    console.log(1)
}
```

```javascript

var myname = "极客时间"
function showName(){
  console.log(myname);
  if(0){
   var myname = "极客邦"
  }
  console.log(myname);
}
showName()
```

