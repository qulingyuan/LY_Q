# 执行上下文

## 概念

执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。

JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为“执行上下文”。

执行栈（调用栈）用于存储在代码执行期间的所有执行上下文。

## 种类

执行上下文有三种：

- 全局上下文：只有一个，在浏览器中是 `window` 对象。
- 函数上下文：函数被调用时才被创建，每次调用函数都会创建一个新的执行上下文。
- Eval 上下文：运行在 `eval` 函数中的代码，不建议使用。

## 属性

在 ES5 中，执行上下文具有以下属性：

- `lexical environment`：词法环境，当获取变量时使用。
- `variable environment`：变量环境，当声明变量时使用。
- `this value`：`this` 值。

在 ES2018 中，执行上下文变成下面的样子（`this` 值被归入词法环境中）：

- `lexical environment`：词法环境，当获取变量或者 this 值时使用。
- `variable environment`：变量环境，当声明变量时使用。
- `code evaluation state`：用于恢复代码执行位置。
- `Function`：执行的任务是函数时使用，表示正在被执行的函数。
- `ScriptOrModule`：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
- `Realm`：使用的基础库和内置对象实例。
- `Generator`：仅生成器上下文有这个属性，表示当前生成器。

## 执行阶段

每个执行上下文都有会经历两个阶段：

1. ### 创建阶段：
   会做代码执行前的准备工作，如声明提升等都是在此阶段做的。

   1. `lexical environment`(词法环境)组件被创建。
   2. `variable environment`(变量环境)组件被创建。

2. ### 执行阶段：
    逐行执行代码，完成所有变量的分配。

了解了执行上下文的两个阶段，再来具体看一下词法环境和变量环境在创建时都做了什么：

- #### `lexical environment`(词法环境)：

   词法环境有两个部分组成：

   1. **环境记录(EnvironmentRecord)**：存储变量和函数声明的实际位置（包括 `this` 绑定）。
   2. **对外部环境的引用**：可以访问其外部词法环境。

   词法环境有两种类型：

   1. **全局环境**：外部环境的引用为 `null`，拥有一个全局对象（`window` 对象），`this` 值指向这个全局对象。
   1. **函数环境**：在函数中定义的变量被存储在环境记录中，除此之外，环境记录中还包含了 `arguments` 对象，对外部环境的引用可能是全局环境，也可能是外部函数环境。

- #### `variable environment`(变量环境)：

   变量环境也是一个词法环境，故其具有词法环境的所有属性。
   

区别在于词法环境用于存储**函数声明和let、const声明的变量(标记为`uninitialized`)**绑定，而且函数声明在变量声明之前，且如果变量名称和函数名称相同，变量名称不会干扰函数名称；变量环境仅用于存储**var声明的变量(标记为 `undefined`)**绑定。

```javascript
let a = 20;  
const b = 30;  
var c;

function multiply(e, f) {  
 var g = 20;  
 return e * f * g;  
}

c = multiply(20, 30);
```

执行上下文如下所示：

```javascript
GlobalExectionContext = {

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      a: < uninitialized >,  
      b: < uninitialized >,  
      multiply: < func >,
      ThisBinding: <Global Object>,
    }  
    outer: <null>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      c: undefined,  
    }  
    outer: <null>  
  }  
}

FunctionExectionContext = {  

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      Arguments: {0: 20, 1: 30, length: 2},
      ThisBinding: <Global Object>,
    },  
    outer: <GlobalLexicalEnvironment>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      g: undefined  
    },  
    outer: <GlobalLexicalEnvironment>  
  }  
}
```

由上可知，`var` 的**变量提升**以及 `let`、`const` 的**暂时性死区**其实就是由于变量的创建和赋值在执行上下文的不同阶段导致的。在执行上下文创建阶段，`var` 声明的变量会被标记为 `undefined`，而 `let`、`const` 声明的变量会被标记为 `uninitialized`。函数的声明提升在变量的声明提升之前也是由于词法环境先于变量环境的创建导致的。

```javascript
console.log(foo);//打印函数

var foo = 1;

function foo(){
    console.log("foo");
}

console.log(foo);//输出 1
```

上面例子证明了函数声明在变量声明之前处理，且如果变量名称和函数名称相同，变量名称不会干扰函数名称。