## 了解闭包前应该知道的概念

Js 是有编译阶段的，js 代码片段在执行前都会被编译。和传统语言(Java)的区别在于，js 不会提前把编译工作做完，而是一边编译一边执行。

编译阶段：编译器。

执行阶段：JS 引擎。

### 作用域链

作用域套作用域，就形成了**作用域链**。

### LHS、RHS

LHS 和 RHS，是 js 引擎在执行代码的时候，查询变量的两种方式；这里的”左“和”右“，是相对于赋值操作来说的，变量出现在赋值操作左侧时，执行的 LHS ，右侧则执行 RHS 操作。

LSH 意味着**变量赋值或写入内存**。

RHS 意味着**变量查找或从内存中读取**。

```javascript
name = 'ly_qu';  //name 在左侧，属于 LHS。
let myName = name;  //name 在右侧，属于 RHS。
```

## 闭包

不属于当前作用域的变量，对于当前作用域来说是一个**自由变量**。

引用了自由变量的函数叫闭包。

### 作用域模型

有两种作用域模型：词法作用域和动态作用域，二者的区别在于**划分作用域的时机**：

词法作用域：也成为静态作用域。在代码书写的时候完成划分，作用域链沿着它**定义的位置**向外延伸。大多数语言都属于该模型（包括 js）。

动态作用域：在代码运行时完成划分，作用域链沿着它的**调用栈**向外延伸。比较冷门，Bash、Perl 等语言采用该模型

先思考一下，下面代码的输出结果是什么？

```javascript
var name = 'ly_qu';

function showName() {
    console.log(name);
}

function changeName() {
    var name = 'chen';
    showName();
}

changeName();
```

分析：

在 showName 函数的函数作用域内查找是否有局部变量 name。

没有找到 name，根据 showName **定义的位置**，查找其上层作用域，即全局作用域，找到了 name 的值是 ly_qu，所以结果是 ly_qu。

作用域关系图如下图所示：

![作用域图](https://gitee.com/qulingyuan/ly_picture/raw/master/img/2022/01/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%9B%BE.png)

运行时的作用域链关系如下：

![作用域链](https://gitee.com/qulingyuan/ly_picture/raw/master/img/2022/01/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.png)

遇到问题最好像上面这样画作用域图来进行分析。

至此，我们对于闭包的理解又更进一步了。

### 循环体与闭包

经典问题，下面代码运行结果是什么？

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}

console.log(i);
```

结果是：

```
5 
5 5 5 5 5
```

分析：

首先，最后一行肯定最先输出，所以先输出一个 5。

for 循环里的 setTimeout 执行了 5 次，每次都会将这个函数的执行推迟 1000ms

```javascript
function() {
  console.log(i);
}
```

但该函数内并不存在变量 i，所以需要向上层作用域找。但此时 for 循环早已执行完毕，变量 i 值已经是 5了，故输出了 5 个 5。

#### 改造上面代码

1. 利用 setTimeout 第三个参数。

   ```javascript
   for (var i = 0; i < 5; i++) {
       setTimeout(function(j) {
           console.log(j);
       }, 1000, i);
   }
   ```

   

2. 在 setTimeout 外面再套一层函数，利用该外部函数的入参来缓存每一个循环中的 i 值。

   ```javascript
   var output = function (i) {
       setTimeout(function() {
           console.log(i);
       }, 1000);
   };
   
   for (var i = 0; i < 5; i++) {
       // 这里的 i 被赋值给了 output 作用域内的变量 i
       output(i);  
   }
   ```

   

3. 使用立即执行函数把 setTimeout 套起来，利用立即执行函数的入参来缓存每一个循环中的 i 的值：

   ```javascript
   for (var i = 0; i < 5; i++) {
       // 这里的 i 被赋值给了立即执行函数作用域内的变量 j
       (function(j) {  
           setTimeout(function() {
               console.log(j);
           }, 1000);
       })(i);
   }
   ```



