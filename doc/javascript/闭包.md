讲闭包前，先谈作用域，因为闭包是作用域的特殊情况。

### 作用域

- 全局作用域
- 函数作用域
- 块级作用域（ES6新增）

**自由变量**：一个变量在当前作用域没有定义，但被使用了，则js会向上级作用域，一层一层一次寻找，直到找到为止；如果到全局作用域都没找到，则报错。

**引用了自由变量的函数，就叫闭包。**
### 闭包

闭包是作用域应用的特殊情况，有两种表现：

- 函数作为参数被传递
- 函数作为返回值被返回

查看两个例子：

```javascript
//函数作为返回值
function create(){
    let a = 100;
    return function(){
        console.log(a);
    }
}
const fn = create();
const a = 200;
fn(); // 100

//函数作为参数被传递
function print(fn){
    let a = 200;
    fn();
}
const a = 100;
function fn(){
    console.log(a);
}
print(fn); // 100
```

### 结论

所有的自由变量的查找，是在**函数定义**的地方向上级作用域查找，不是在执行的地方！！！

### 实际开发中闭包的应用

经常使用闭包来隐藏数据，例如：

```javascript
//闭包隐藏数据，只提供API
function createCache(){
    const data = {}; // 闭包中的数据，被隐藏，不被外界访问
    return {
        set:function(key,val){
            data[key] = val;
        },
        get:function(key){
            return data[key];
        }
    }
}

const c = createCache();
c.set("a",100);
console.log(c.get("a"));
```

共用变量

```javascript
//创建10个<a>标签，点击的时候弹出对应的序号
//错误写法案例
let i,a;
for(i = 0;i < 10;i++){
    a = document.createElement("a");
    a.innerHTML = i+"<br>";
    a.addEventListener("click",function(e){
        e.preventDefault();
        alert(i);
    })
    document.body.appendChild(a);
}
```

上面代码，不能实现功能。因为i定义在全局，for循环执行很快，而addEventListener可能在数秒后才触发点击事件。所以最后addEventListener中的 i 已经变成了10；

正确写法应该是把 i 放入到for循环的块作用域中，这样就保证了每次addEentListener中的 i 都是每次循环的 i 的值。

```javascript
//创建10个<a>标签，点击的时候弹出对应的序号
//正确写法
let a;
for(let i = 0;i < 10;i++){
    a = document.createElement("a");
    a.innerHTML = i+"<br>";
    a.addEventListener("click",function(e){
        e.preventDefault();
        alert(i);
    })
    document.body.appendChild(a);
}
```









https://github.com/lgwebdream/FE-Interview/issues/17

